int a,b;
scanf("%d",a);
scanf("%d",b);
/*
输入：12回车13回车
结果：a=12，b=13
则%d只识别数字
*/
char c,d;
scanf("%c",c);
scanf("%c",d);
/*
输入：a回车b回车
结果：c=‘a’，d=10
出现这个原因就是scanf（）函数
（你要是换成getchar()结果也一样）是从输入流缓冲区里读取值的，
而并非是从键盘（也就是终端）缓冲区里读取，
当按下q,q先放在键盘缓冲区里，
当按下回车后，q以及“\n”进入到输入缓冲区里面，
所以第一次q被取走后，第二次读入函数直接从缓冲区里把“\n”取走了。
所以在读取成功后，就不会再从终端（键盘）读取，
要解决这个的办法就是在第二次读取之前，清空缓冲区的残留数据。
————————————————
版权声明：本文为CSDN博主「渴望飞翔的猪」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u014360239/article/details/38018753
*/

/*解决1*/
scanf("%c",c);
getchar();
scanf("%c",d);
/*
用getchar吃掉回车（其实是换行）符
*/

/*解决2*/
int i
scanf("%c",c);
while((i = getchar()) != '\n' && i != EOF);
scanf("%c",d);
/*
不停地使用getchar()获取缓冲区中字符，
直到获取的字符c是换行符’\n’或者是文件结尾符EOF为止。
这个方法可以完美清除输入缓冲区，并且具备可移植性。  
*/

/*解决3*/
scanf("%c",c);
fflush(stdin);
scanf("%c",d);
/*
fflush(stdin)能把键盘输入缓存区清0
类似地rewind(stdin)把指针指到起始处
但这些底层指令不推荐使用
*/